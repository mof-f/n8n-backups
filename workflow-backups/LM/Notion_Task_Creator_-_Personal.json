{
  "versionid": "56965124-bb1d-4b30-84d7-99b6dfa43c33",
  "workflowid": "nhGsm31pQx1eeWsk",
  "createdat": "2025-11-01T11:50:59.198Z",
  "updatedat": "2025-11-01T11:50:59.198Z",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "7b11ffd1-df34-4c3f-9509-3aba01867f03",
        "authentication": "headerAuth",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -496,
        -144
      ],
      "id": "44c073d6-abef-45dd-bb15-ff58bc61dd2c",
      "name": "Webhook",
      "webhookId": "7b11ffd1-df34-4c3f-9509-3aba01867f03",
      "credentials": {
        "httpHeaderAuth": {
          "id": "k9lQZ1gYvf8WoBEb",
          "name": "Header Auth - Task Webhook"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.notion.com/v1/pages",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Notion-Version",
              "value": "2022-06-28"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json) }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        672,
        -144
      ],
      "id": "0f1132ec-e2a1-4fa3-b577-adc5f8d6bdc0",
      "name": "POST to Notion",
      "credentials": {
        "httpHeaderAuth": {
          "id": "AoLRfV3kJAAxUfXj",
          "name": "Notion - Header Auth"
        }
      }
    },
    {
      "parameters": {
        "content": "## Version Control\n2025-10-13 13:58 LM - initial setup and proof of working code\n2025-10-13 14:05 LM - added a respond to webhook node\n2025-10-15 11:14 LM - updated to handle more descriptive narrative input and setup a 'today' task option\n2025-10-15 12:34 LM - corrected 'today' date calculation logic",
        "height": 480,
        "width": 940,
        "color": 4
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -528,
        128
      ],
      "id": "0a3482b6-47d5-4db9-a64a-38071b9bd392",
      "name": "Sticky Note3"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"message\": \"✅ Task added to Inbox: {{ $('prepNotionPayload').item.json.properties.Task.title[0].text.content }}\"\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        864,
        -144
      ],
      "id": "89d3da9b-8346-4248-8baf-469258e64612",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "jsCode": "// ========== CONFIG ==========\nconst FORCE_INBOX_STATUS = true; // Force \"Inbox\" unless AI says \"Today\"\n// ============================\n\nconst taskData = $input.first().json.message.content; \nconst propertySchema = $('parseProps').first().json.propertySchema;\nconst databaseId = $('GetDatabaseProps').first().json.id;\n\nfunction formatProperty(value, type) {\n  // Skip null, undefined, or empty string\n  if (value === null || value === undefined || value === '') {\n    return null;\n  }\n  \n  switch(type) {\n    case 'title':\n      return { \n        title: [{ text: { content: String(value) } }] \n      };\n    \n    case 'rich_text':\n      return { \n        rich_text: [{ text: { content: String(value) } }] \n      };\n    \n    case 'select':\n      return { \n        select: { name: String(value) } \n      };\n    \n    case 'multi_select':\n      const values = Array.isArray(value) ? value : [value];\n      const filtered = values.filter(v => v !== null && v !== undefined && v !== '');\n      return filtered.length > 0 ? {\n        multi_select: filtered.map(v => ({ name: String(v) }))\n      } : null;\n    \n    case 'status':\n      return { \n        status: { name: String(value) } \n      };\n    \n    case 'date':\n      const dateStr = value.includes('T') ? value.split('T')[0] : value;\n      return { \n        date: { start: dateStr } \n      };\n    \n    case 'checkbox':\n      return { \n        checkbox: Boolean(value) \n      };\n    \n    case 'number':\n      return { \n        number: Number(value) \n      };\n    \n    default:\n      return null;\n  }\n}\n\nconst properties = {};\n\n// Build properties dynamically from schema and AI output\nfor (const [propName, propConfig] of Object.entries(propertySchema)) {\n  const value = taskData[propName];\n  \n  // Only add property if it has a value (skip nulls)\n  if (value !== undefined && value !== null && value !== '') {\n    const formatted = formatProperty(value, propConfig.type);\n    if (formatted !== null) {\n      properties[propName] = formatted;\n    }\n  }\n  \n  // Special handling for checkbox - include false values\n  if (propConfig.type === 'checkbox' && value !== undefined && value !== null) {\n    properties[propName] = formatProperty(value, 'checkbox');\n  }\n}\n\n// ========== SMART STATUS OVERRIDE ==========\nif (FORCE_INBOX_STATUS) {\n  // Only force \"Inbox\" if AI didn't set it to \"Today\"\n  if (taskData.Status !== \"Today\") {\n    properties['Status'] = { status: { name: 'Inbox' } };\n  }\n}\n// ===========================================\n\nreturn [{\n  json: {\n    parent: { \n      database_id: databaseId \n    },\n    properties: properties\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        480,
        -144
      ],
      "id": "6c87a50b-2c0d-4c11-b3cd-335b59b1e5bb",
      "name": "prepNotionPayload"
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "GPT-4O-MINI"
        },
        "messages": {
          "values": [
            {
              "content": "=You are a GTD task parser. Parse the user's natural language input and extract task properties intelligently.\n\nVoice input: {{$json.userInput}}\n\nDatabase schema with available properties:\n{{JSON.stringify($json.propertySchema, null, 2)}}\n\nCurrent date references (Adelaide timezone):\n- Today: {{$json.dates.today}}\n- Tomorrow: {{$json.dates.tomorrow}}\n- This weekend: {{$json.dates.thisWeekend}}\n- Next week: {{$json.dates.nextWeek}}\n\nTASK EXTRACTION RULES:\n- Extract the core actionable task from narrative descriptions\n- Examples:\n  * \"I need to call the dentist today\" → Task: \"Call dentist\"\n  * \"Buy scissors on Amazon\" → Task: \"Buy scissors on Amazon\"\n  * \"Remind me to email Sarah about the project\" → Task: \"Email Sarah about the project\"\n\nTODAY TASK DETECTION:\n- If input mentions \"today\", \"urgent\", \"ASAP\", or implies immediate action:\n  * Set Status = \"Today\"\n  * Set Due Date = {{$json.dates.today}}\n- Otherwise:\n  * Set Status = \"Inbox\"\n  * Leave Due Date = null\n\nProperty type rules:\n- title: Use for the main task name (extracted from narrative)\n- rich_text: Use for notes or additional context from the input\n- date: Use YYYY-MM-DD format. Handle relative dates using the references above:\n  * \"today\" = {{$json.dates.today}}\n  * \"tomorrow\" = {{$json.dates.tomorrow}}\n  * \"this weekend\" = {{$json.dates.thisWeekend}}\n  * \"next week\" = {{$json.dates.nextWeek}}\n- select: Pick ONE option from the provided list\n- multi_select: Pick one or more options as an array\n- status: Pick ONE option from the provided list\n- checkbox: true or false\n- number: numeric value only\n\nImportant:\n- Use EXACT matches for select/multi_select/status options from the schema\n- Intelligently infer Priority, Context, Domain, and Type from the task description\n- Extract any additional details into Notes\n- Leave fields null if not mentioned or unclear\n- Use the exact dates provided in the current date references\n\nReturn ONLY valid JSON matching the schema.",
              "role": "assistant"
            }
          ]
        },
        "jsonOutput": true,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.8,
      "position": [
        144,
        -144
      ],
      "id": "20581ee0-6b6d-417c-aec1-8141a7778790",
      "name": "Personal Task Agent",
      "credentials": {
        "openAiApi": {
          "id": "ZIhKmLFbnV3eHkVn",
          "name": "OpenAi SDL(personal)"
        }
      }
    },
    {
      "parameters": {
        "resource": "database",
        "databaseId": {
          "__rl": true,
          "value": "28629734-f237-8011-9296-db67c90f5f75",
          "mode": "list",
          "cachedResultName": "GTD Tasks",
          "cachedResultUrl": "https://www.notion.so/28629734f23780119296db67c90f5f75"
        },
        "simple": false
      },
      "type": "n8n-nodes-base.notion",
      "typeVersion": 2.2,
      "position": [
        -288,
        -144
      ],
      "id": "0792a61d-0c17-4f9e-b67e-4c20a7105c87",
      "name": "GetDatabaseProps",
      "credentials": {
        "notionApi": {
          "id": "bJEiPdmKyoxumxIL",
          "name": "Notion - Moff-SDL-Private"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Get the database schema from the previous Notion node\nconst database = $input.first().json;\nconst properties = database.properties;\n\n// Property types with predefined options\nconst optionTypes = ['select', 'multi_select', 'status'];\n\n// Property types that are read-only (can't be set)\nconst readOnlyTypes = ['formula', 'rollup', 'created_time', 'created_by', 'last_edited_time', 'last_edited_by'];\n\n// Extract all writable properties\nconst propertySchema = {};\n\nfor (const [propertyName, propertyConfig] of Object.entries(properties)) {\n  const propertyType = propertyConfig.type;\n  \n  // Skip read-only properties\n  if (readOnlyTypes.includes(propertyType)) {\n    continue;\n  }\n  \n  const propInfo = {\n    type: propertyType\n  };\n  \n  // Add options for properties that have them\n  if (optionTypes.includes(propertyType)) {\n    const options = propertyConfig[propertyType]?.options;\n    if (options && Array.isArray(options)) {\n      propInfo.options = options.map(opt => opt.name);\n    }\n  }\n  \n  propertySchema[propertyName] = propInfo;\n}\n\n// ========== CALCULATE ADELAIDE DATES ==========\nconst now = new Date();\n\n// Get Adelaide date\nconst adelaideDate = new Date(now.toLocaleString('en-US', {\n  timeZone: 'Australia/Adelaide'\n}));\n\n// Today in Adelaide\nconst today = adelaideDate.toLocaleDateString('en-CA'); // YYYY-MM-DD\n\n// Tomorrow\nconst tomorrowDate = new Date(adelaideDate);\ntomorrowDate.setDate(tomorrowDate.getDate() + 1);\nconst tomorrow = tomorrowDate.toLocaleDateString('en-CA');\n\n// This weekend (next Saturday)\nconst weekendDate = new Date(adelaideDate);\nconst daysUntilSaturday = (6 - adelaideDate.getDay() + 7) % 7 || 7;\nweekendDate.setDate(weekendDate.getDate() + daysUntilSaturday);\nconst thisWeekend = weekendDate.toLocaleDateString('en-CA');\n\n// Next week\nconst nextWeekDate = new Date(adelaideDate);\nnextWeekDate.setDate(nextWeekDate.getDate() + 7);\nconst nextWeek = nextWeekDate.toLocaleDateString('en-CA');\n\nconst dateReferences = {\n  today,\n  tomorrow,\n  thisWeekend,\n  nextWeek\n};\n// ===============================================\n\n// Get the original webhook data\nconst webhookData = $('Webhook').first().json;\n\n// Pass everything forward\nreturn [{\n  json: {\n    userInput: webhookData.body.text,\n    propertySchema: propertySchema,\n    dates: dateReferences\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -80,
        -144
      ],
      "id": "a3a97f73-2162-4f28-a97f-2be08f890409",
      "name": "parseProps"
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "GetDatabaseProps",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "POST to Notion": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "prepNotionPayload": {
      "main": [
        [
          {
            "node": "POST to Notion",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Personal Task Agent": {
      "main": [
        [
          {
            "node": "prepNotionPayload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GetDatabaseProps": {
      "main": [
        [
          {
            "node": "parseProps",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "parseProps": {
      "main": [
        [
          {
            "node": "Personal Task Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "workflow_name": "Notion Task Creator - Personal"
}
{
  "versionid": "ab3033a8-a093-4a8c-a3f9-5a2a483d316a",
  "workflowid": "XREHV4y8QuHrrf2i",
  "createdat": "2025-11-12T09:31:48.993Z",
  "updatedat": "2025-11-12T09:31:48.993Z",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "daa7e700-93ec-45eb-bedb-0a33c4934a4d",
        "authentication": "headerAuth",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -496,
        -144
      ],
      "id": "7cc0108a-f54d-438f-aecb-f42de4c7d05d",
      "name": "Webhook",
      "webhookId": "daa7e700-93ec-45eb-bedb-0a33c4934a4d",
      "credentials": {
        "httpHeaderAuth": {
          "id": "k9lQZ1gYvf8WoBEb",
          "name": "Header Auth - Task Webhook"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.notion.com/v1/pages",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Notion-Version",
              "value": "2022-06-28"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json) }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        656,
        -144
      ],
      "id": "06910f99-e59b-46b3-b67f-4bd24d209850",
      "name": "POST to Notion",
      "credentials": {
        "httpHeaderAuth": {
          "id": "AoLRfV3kJAAxUfXj",
          "name": "Notion - Header Auth"
        }
      }
    },
    {
      "parameters": {
        "content": "## Version Control\n2025-10-19 17:34 LM - initial setup (cloned from personal) and proof of working code\n2025-10-19 18:16 LM - updated for `Ready for Development` status\n2025-10-19 18:16 LM - updated response to use correct task response",
        "height": 480,
        "width": 940,
        "color": 4
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -528,
        96
      ],
      "id": "06cc832c-74e8-4b7f-bee8-9f01628ee832",
      "name": "Sticky Note3"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"message\": \"✅ {{ $('Personal Task Agent').item.json.message.content.Item }} added to Shopping.\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        848,
        -144
      ],
      "id": "bb4dd8c9-187d-4e78-aa07-78989bb9d293",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "jsCode": "// ========== CONFIG ==========\nconst AUTO_SET_CREATED_DATE = true; // Auto-set CreatedDate to today\n// ============================\n\nconst taskData = $input.first().json.message.content; \nconst propertySchema = $('parseProps').first().json.propertySchema;\nconst databaseId = $('GetDatabaseProps').first().json.id;\n\nfunction formatProperty(value, type) {\n  // Skip null, undefined, or empty string\n  if (value === null || value === undefined || value === '') {\n    return null;\n  }\n  \n  switch(type) {\n    case 'title':\n      return { \n        title: [{ text: { content: String(value) } }] \n      };\n    \n    case 'rich_text':\n      return { \n        rich_text: [{ text: { content: String(value) } }] \n      };\n    \n    case 'select':\n      return { \n        select: { name: String(value) } \n      };\n    \n    case 'multi_select':\n      const values = Array.isArray(value) ? value : [value];\n      const filtered = values.filter(v => v !== null && v !== undefined && v !== '');\n      return filtered.length > 0 ? {\n        multi_select: filtered.map(v => ({ name: String(v) }))\n      } : null;\n    \n    case 'status':\n      return { \n        status: { name: String(value) } \n      };\n    \n    case 'date':\n      const dateStr = value.includes('T') ? value.split('T')[0] : value;\n      return { \n        date: { start: dateStr } \n      };\n    \n    case 'checkbox':\n      return { \n        checkbox: Boolean(value) \n      };\n    \n    case 'number':\n      return { \n        number: Number(value) \n      };\n    \n    case 'url':\n      return {\n        url: String(value)\n      };\n    \n    case 'people':\n      // People property - expects array of user objects\n      // AI will set this as null, but keeping handler for future use\n      if (Array.isArray(value)) {\n        return {\n          people: value.map(person => ({ id: person.id || person }))\n        };\n      }\n      return null;\n    \n    default:\n      return null;\n  }\n}\n\nconst properties = {};\n\n// Build properties dynamically from schema and AI output\nfor (const [propName, propConfig] of Object.entries(propertySchema)) {\n  const value = taskData[propName];\n  \n  // Only add property if it has a value (skip nulls)\n  if (value !== undefined && value !== null && value !== '') {\n    const formatted = formatProperty(value, propConfig.type);\n    if (formatted !== null) {\n      properties[propName] = formatted;\n    }\n  }\n  \n  // Special handling for checkbox - include false values\n  if (propConfig.type === 'checkbox' && value !== undefined && value !== null) {\n    properties[propName] = formatProperty(value, 'checkbox');\n  }\n}\n\n// ========== AUTO-SET CREATED DATE ==========\nif (AUTO_SET_CREATED_DATE) {\n  // Set CreatedDate to today in Adelaide timezone\n  const dates = $('parseProps').first().json.dates;\n  properties['CreatedDate'] = { \n    date: { start: dates.today } \n  };\n}\n// ===========================================\n\nreturn [{\n  json: {\n    parent: { \n      database_id: databaseId \n    },\n    properties: properties\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        464,
        -144
      ],
      "id": "9ca28fc5-d2fb-41c9-aaef-85a7cd1aa11d",
      "name": "prepNotionPayload"
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "GPT-4O-MINI"
        },
        "messages": {
          "values": [
            {
              "content": "=You are a shopping list parser for a personal inventory system. Parse the user's natural language input and extract item properties intelligently.\n\nVoice input: {{$json.userInput}}\n\nDatabase schema with available properties:\n{{JSON.stringify($json.propertySchema, null, 2)}}\n\nCurrent date references (Adelaide timezone):\n- Today: {{$json.dates.today}}\n- Tomorrow: {{$json.dates.tomorrow}}\n- This Friday: {{$json.dates.thisFriday}}\n- This weekend: {{$json.dates.thisWeekend}}\n- Next week: {{$json.dates.nextWeek}}\n\nCRITICAL: SCAN THE ENTIRE INPUT FOR THESE KEYWORDS REGARDLESS OF POSITION!\n\nSHOP / SOURCE DETECTION (always check the full input):\n- Contains \"Bunnings\", \"bunnings\", \"hardware store\", \"hardware\" → \"Hardware\"\n- Contains \"JB Hi-Fi\", \"JB\", \"electronics store\", \"tech store\" → \"Tech\"\n- Contains \"Coles\", \"coles\", \"Woolworths\", \"woolies\", \"woolworths\", \"supermarket\", \"groceries\" → \"Supermarket\"\n- Contains \"chemist\", \"pharmacy\", \"Chemist Warehouse\" → \"Pharmacy\"\n- Contains \"Amazon\", \"amazon\" → \"Amazon\"\n- Contains \"eBay\", \"ebay\" → \"eBay\"\n- Contains \"specialty store\", \"specialty shop\" → \"Specialty\"\n- If no shop mentioned but contains \"online order\", \"online shopping\" → Check category, default to \"Amazon\"\n- If no shop detected at all → Use \"Other\"\n\nPRIORITY AND NEEDED BY DATE RULES (check in this order):\n\n1. URGENT PURCHASES - Need immediately:\n   Keywords: \"today\", \"now\", \"urgent\", \"ASAP\", \"ran out\", \"need immediately\", \"critical\"\n   Sets:\n   * Priority = \"High\"\n   * Needed by = {{$json.dates.today}}\n   * In cart? = true\n\n2. THIS WEEK PURCHASES - Scheduled soon:\n   Keywords: \"this week\", \"by Friday\", \"by weekend\", \"before weekend\", \"by end of week\", \"soon\"\n   Sets:\n   * Priority = \"Medium\"\n   * Needed by = {{$json.dates.thisFriday}} (or {{$json.dates.thisWeekend}} if \"weekend\" mentioned)\n   * In cart? = false\n\n3. CASUAL PURCHASES - No urgency (default):\n   Keywords: \"next time\", \"when I order\", \"eventually\", \"sometime\", \"not urgent\", OR no timing keywords\n   Sets:\n   * Priority = \"Low\"\n   * Needed by = null\n   * In cart? = false\n\nCATEGORY DETECTION (can be multiple):\n- Cleaning supplies, batteries, light bulbs, paper towels → \"Household\", \"Consumables\"\n- Screwdrivers, hammer, drill bits, nails, screws, tools → \"Tools\"\n- Food items, snacks, beverages, produce → \"Groceries\", \"Consumables\"\n- Phone accessories, cables, computer parts → \"Electronics\"\n- Pens, paper, notebooks, printer ink → \"Office\", \"Consumables\"\n- Socks, shirts, jeans, clothes → \"Clothing\"\n- Birthday items, presents → \"Gifts\"\n- Garden supplies, fertiliser, plants, seeds, soil → \"Household\"\n\nProperty type rules:\n- title: Use for \"Item\" - the main item name (e.g., \"Citrus fertiliser\", \"Socks\", \"AA batteries\")\n- rich_text: Use for \"Notes\" for brand preferences, quantity, timing context, or other details mentioned\n- select: Use exact option from available choices for \"Priority\" and \"Shop / Source\"\n- multi_select: Can use multiple options for \"Category\" if item fits multiple categories\n- date: Use YYYY-MM-DD format for \"Needed by\":\n  * \"today\" or \"now\" → {{$json.dates.today}}\n  * \"this week\" or \"by Friday\" → {{$json.dates.thisFriday}}\n  * \"weekend\" or \"by weekend\" → {{$json.dates.thisWeekend}}\n  * \"tomorrow\" → {{$json.dates.tomorrow}}\n  * \"next week\" → {{$json.dates.nextWeek}}\n  * No mention or \"next time\" → null\n- checkbox: \"In cart?\" = true only if urgency is high or explicitly mentioned\n- checkbox: \"Bought\" = false (always, since this is a new item)\n- url: \"Link\" = null (unless user provides a specific link)\n- number: \"Est. price\" = null (unless user mentions approximate price)\n\nIMPORTANT: The shop name can appear ANYWHERE in the input - at the beginning, middle, or end. Always scan the complete sentence for shop keywords.\n\nOUTPUT ONLY VALID JSON matching the Notion property types. Do not include explanations.",
              "role": "assistant"
            }
          ]
        },
        "jsonOutput": true,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.8,
      "position": [
        128,
        -144
      ],
      "id": "45457ff8-1739-44a1-90cc-49244912865c",
      "name": "Personal Task Agent",
      "credentials": {
        "openAiApi": {
          "id": "ZIhKmLFbnV3eHkVn",
          "name": "OpenAi SDL(personal)"
        }
      }
    },
    {
      "parameters": {
        "resource": "database",
        "databaseId": {
          "__rl": true,
          "value": "b8fe663b-6b5d-46d3-a303-acaf9f0423a4",
          "mode": "list",
          "cachedResultName": "Shopping",
          "cachedResultUrl": "https://www.notion.so/b8fe663b6b5d46d3a303acaf9f0423a4"
        },
        "simple": false
      },
      "type": "n8n-nodes-base.notion",
      "typeVersion": 2.2,
      "position": [
        -288,
        -144
      ],
      "id": "f88d8622-602d-430b-9c20-81de41698047",
      "name": "GetDatabaseProps",
      "credentials": {
        "notionApi": {
          "id": "bJEiPdmKyoxumxIL",
          "name": "Notion - Moff-SDL-Private"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Get the database schema from the previous Notion node\nconst database = $input.first().json;\nconst properties = database.properties;\n\n// Property types with predefined options\nconst optionTypes = ['select', 'multi_select', 'status'];\n\n// Property types that are read-only (can't be set)\nconst readOnlyTypes = ['formula', 'rollup', 'created_time', 'created_by', 'last_edited_time', 'last_edited_by'];\n\n// Extract all writable properties\nconst propertySchema = {};\n\nfor (const [propertyName, propertyConfig] of Object.entries(properties)) {\n  const propertyType = propertyConfig.type;\n  \n  // Skip read-only properties\n  if (readOnlyTypes.includes(propertyType)) {\n    continue;\n  }\n  \n  const propInfo = {\n    type: propertyType\n  };\n  \n  // Add options for properties that have them\n  if (optionTypes.includes(propertyType)) {\n    const options = propertyConfig[propertyType]?.options;\n    if (options && Array.isArray(options)) {\n      propInfo.options = options.map(opt => opt.name);\n    }\n  }\n  \n  propertySchema[propertyName] = propInfo;\n}\n\n// ========== CALCULATE ADELAIDE DATES ==========\nconst now = new Date();\n\n// Get Adelaide date\nconst adelaideDate = new Date(now.toLocaleString('en-US', {\n  timeZone: 'Australia/Adelaide'\n}));\n\n// Today in Adelaide\nconst today = adelaideDate.toLocaleDateString('en-CA'); // YYYY-MM-DD\n\n// Tomorrow\nconst tomorrowDate = new Date(adelaideDate);\ntomorrowDate.setDate(tomorrowDate.getDate() + 1);\nconst tomorrow = tomorrowDate.toLocaleDateString('en-CA');\n\n// This Friday\nconst thisFridayDate = new Date(adelaideDate);\nconst dayOfWeek = adelaideDate.getDay(); // 0 = Sunday, 5 = Friday\nconst daysUntilFriday = (5 - dayOfWeek + 7) % 7;\n\nif (daysUntilFriday === 0) {\n  // Today IS Friday, use next Friday\n  thisFridayDate.setDate(thisFridayDate.getDate() + 7);\n} else {\n  thisFridayDate.setDate(thisFridayDate.getDate() + daysUntilFriday);\n}\nconst thisFriday = thisFridayDate.toLocaleDateString('en-CA');\n\n// This weekend (next Saturday)\nconst weekendDate = new Date(adelaideDate);\nconst daysUntilSaturday = (6 - adelaideDate.getDay() + 7) % 7 || 7;\nweekendDate.setDate(weekendDate.getDate() + daysUntilSaturday);\nconst thisWeekend = weekendDate.toLocaleDateString('en-CA');\n\n// Next week\nconst nextWeekDate = new Date(adelaideDate);\nnextWeekDate.setDate(nextWeekDate.getDate() + 7);\nconst nextWeek = nextWeekDate.toLocaleDateString('en-CA');\n\nconst dateReferences = {\n  today,\n  tomorrow,\n  thisFriday,    // ← Added this\n  thisWeekend,\n  nextWeek\n};\n// ===============================================\n\n// Get the original webhook data\nconst webhookData = $('Webhook').first().json;\n\n// Pass everything forward\nreturn [{\n  json: {\n    userInput: webhookData.body.text,\n    propertySchema: propertySchema,\n    dates: dateReferences\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -80,
        -144
      ],
      "id": "f61844b5-487e-46ca-9444-71345cf6119f",
      "name": "parseProps"
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "GetDatabaseProps",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "POST to Notion": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "prepNotionPayload": {
      "main": [
        [
          {
            "node": "POST to Notion",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Personal Task Agent": {
      "main": [
        [
          {
            "node": "prepNotionPayload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GetDatabaseProps": {
      "main": [
        [
          {
            "node": "parseProps",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "parseProps": {
      "main": [
        [
          {
            "node": "Personal Task Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "workflow_name": "Notion Things to Buy Creator"
}
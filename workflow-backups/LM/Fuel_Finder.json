{"versionid":"fcd25f51-ef05-4ebf-b3d9-441142becdaf","workflowid":"5o6wQj4Jnc9WjYjk","createdat":"2025-11-01T11:50:44.766Z","updatedat":"2025-11-01T11:50:44.766Z","nodes":[{"parameters":{"url":"https://petrolspy.com.au/webservice-1/station/box","sendQuery":true,"queryParameters":{"parameters":[{"name":"neLat","value":"={{ $json.neLat }}"},{"name":"neLng","value":"={{ $json.neLng }}"},{"name":"swLat","value":"={{ $json.swLat }}"},{"name":"swLng","value":"={{ $json.swLng }}"},{"name":"ts","value":"={{ Date.now() + (22 * 24 * 60 * 60 * 1000) }}"},{"name":"_","value":"={{Date.now() + (22 * 24 * 60 * 60 * 1000) - 300}}"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[-448,448],"id":"af4733fc-80b5-4d46-acc7-c5692c32ab35","name":"HTTP Request"},{"parameters":{"jsCode":"// --- Origin & params ---\nconst originLat = $('Webhook').first().json.body.lat;\nconst originLon = $('Webhook').first().json.body.lon;\n\nconst litresToBuy = Number($('Webhook').first().json.body.litresToBuy ?? 40); // L\nconst lPer100     = Number($('Webhook').first().json.body.lPer100 ?? 8.5);    // L/100km\nconst roadFactor  = Number($('Webhook').first().json.body.roadFactor ?? 1.5); // road vs straight line\nconst onWay       = Boolean($('Webhook').first().json.body.onWay ?? false);   // true = one-way\n\nfunction haversine(lat1, lon1, lat2, lon2) {\n  const R = 6371;\n  const dLat = (lat2 - lat1) * Math.PI/180;\n  const dLon = (lon2 - lon1) * Math.PI/180;\n  const a = Math.sin(dLat/2)**2 +\n    Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*\n    Math.sin(dLon/2)**2;\n  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n}\nconst round = (n, p=1) => Math.round(n * (10**p)) / (10**p);\n\n// ---- Ingest: support two shapes ----\nlet rawArray = $input.first()?.json?.message?.list;\nif (!Array.isArray(rawArray)) {\n  // Fall back to \"many items\" shape\n  rawArray = $input.all().map(it => it.json);\n}\n\n// ---- Normalize each station to a common shape ----\nfunction normalize(station) {\n  // If already mapped upstream (has .price), keep it\n  const alreadyMapped = station?.price != null && station?.location;\n  if (alreadyMapped) {\n    return {\n      name: station.name,\n      suburb: station.suburb,\n      address: station.address,\n      lat: station.location?.y,\n      lon: station.location?.x,\n      price_cpl: Number(station.price)\n    };\n  }\n  // Otherwise, extract from raw API object\n  return {\n    name: station.name,\n    suburb: station.suburb,\n    address: station.address,\n    lat: station.location?.y,\n    lon: station.location?.x,\n    price_cpl: Number(station?.prices?.U91?.amount)\n  };\n}\n\nconst normalized = rawArray\n  .map(normalize)\n  .filter(s =>\n    Number.isFinite(s?.lat) &&\n    Number.isFinite(s?.lon) &&\n    Number.isFinite(s?.price_cpl)\n  );\n\n// ---- Enrich with travel-aware values ----\nconst enriched = normalized.map(s => {\n  const distance_km = haversine(originLat, originLon, s.lat, s.lon);\n  const road_km     = distance_km * roadFactor;\n  const trip_km     = road_km * (onWay ? 1 : 2);\n  const trip_fuel_L = (trip_km * lPer100) / 100;\n  const trip_cost_$ = (s.price_cpl / 100) * trip_fuel_L; // price_cpl is c/L\n  const effective_cpl = s.price_cpl + ((trip_cost_$ / litresToBuy) * 100);\n\n  return {\n    json: {\n      name: s.name,\n      suburb: s.suburb,\n      address: s.address,\n      location: { x: s.lon, y: s.lat },\n      price_cpl: round(s.price_cpl, 1),\n      distance_km: round(distance_km, 2),\n      road_km: round(road_km, 2),\n      trip_km: round(trip_km, 2),\n      trip_cost_$: round(trip_cost_$, 2),\n      effective_price_cpl: round(effective_cpl, 1)\n    }\n  };\n});\n\n// ---- Sort best → worst by effective c/L & rank ----\nenriched.sort((a, b) => a.json.effective_price_cpl - b.json.effective_price_cpl);\nenriched.forEach((it, i) => it.json.rank = i + 1);\n\nreturn enriched;"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-256,448],"id":"8e7a9625-19de-4e62-8b6f-b60188c90821","name":"pricesU91"},{"parameters":{"httpMethod":"POST","path":"fuelprices","responseMode":"responseNode","options":{"ignoreBots":false}},"type":"n8n-nodes-base.webhook","typeVersion":2.1,"position":[-832,448],"id":"85a349d3-9ee3-4a04-906f-78702682b141","name":"Webhook","webhookId":"1f5a671a-3fd7-4466-aafb-d7d881d7ca1d"},{"parameters":{"authentication":"oAuth2","select":"user","user":{"__rl":true,"value":"U07ESV87493","mode":"list","cachedResultName":"luke"},"text":"=*⛽ Fuel — Best by Effective Price*\n\n*Overall:* {{ $json.bestOverall ? `${$json.bestOverall.price_cpl} c/L (eff ${$json.bestOverall.effective_price_cpl} c/L) — ${$json.bestOverall.name}, ${$json.bestOverall.suburb} (${Math.round($json.bestOverall.distance_km*10)/10} km) ${$json.bestOverall.mapsUrl ? `<${$json.bestOverall.mapsUrl}|navigate>` : ''}` : 'n/a' }}\n*Within 5 km:* {{ $json.bestWithin.km5 ? `${$json.bestWithin.km5.price_cpl} c/L (eff ${$json.bestWithin.km5.effective_price_cpl} c/L) — ${$json.bestWithin.km5.name}, ${$json.bestWithin.km5.suburb} (${Math.round($json.bestWithin.km5.distance_km*10)/10} km) ${$json.bestWithin.km5.mapsUrl ? `<${$json.bestWithin.km5.mapsUrl}|navigate>` : ''}` : 'none' }}\n*Within 10 km:* {{ $json.bestWithin.km10 ? `${$json.bestWithin.km10.price_cpl} c/L (eff ${$json.bestWithin.km10.effective_price_cpl} c/L) — ${$json.bestWithin.km10.name}, ${$json.bestWithin.km10.suburb} (${Math.round($json.bestWithin.km10.distance_km*10)/10} km) ${$json.bestWithin.km10.mapsUrl ? `<${$json.bestWithin.km10.mapsUrl}|navigate>` : ''}` : 'none' }}","otherOptions":{"includeLinkToWorkflow":false}},"type":"n8n-nodes-base.slack","typeVersion":2.3,"position":[336,624],"id":"bde2a7b9-6fae-4246-9324-ea60adc8c2f4","name":"Send a message","webhookId":"0e94a685-4f9a-4f38-9847-8e21acc4fb4b"},{"parameters":{"jsCode":"// Input: many items like { json: { name, suburb, address, location:{x,y}, price_cpl, distance_km, road_km, effective_price_cpl, ... } }\n\nfunction round(n, p=1){ return Math.round(n * (10**p)) / (10**p); }\nfunction pickBest(arr){\n  return arr.reduce((min, s) => (min && min.effective_price_cpl <= s.effective_price_cpl) ? min : s, null);\n}\nfunction amapLink(lat, lon, label){\n  const q = encodeURIComponent(label || 'Fuel');\n  return `https://maps.apple.com/?q=${q}&daddr=${lat},${lon}`;\n}\n\nconst all = $input.all().map(it => it.json)\n  .filter(s =>\n    Number.isFinite(s.effective_price_cpl) &&\n    Number.isFinite(s.distance_km) &&\n    Number.isFinite(s.road_km)\n  );\n\n// Pick by effective price in each bucket (using *driving* km)\nconst bestOverall = pickBest(all);\nconst best5km     = pickBest(all.filter(s => s.road_km <= 5));\nconst best10km    = pickBest(all.filter(s => s.road_km <= 10));\n\nfunction view(s){\n  if(!s) return null;\n  const lat = s.location?.y, lon = s.location?.x;\n  return {\n    name: s.name,\n    suburb: s.suburb,\n    address: s.address,\n    price_cpl: round(s.price_cpl, 1),\n    effective_price_cpl: round(s.effective_price_cpl, 1),\n    distance_km: round(s.distance_km, 2),   // straight-line (FYI)\n    road_km: round(s.road_km, 2),           // driving estimate (used for buckets)\n    mapsUrl: (Number.isFinite(lat) && Number.isFinite(lon)) ? amapLink(lat, lon, s.name) : null\n  };\n}\n\nconst summary = {\n  counts: { considered: all.length, totalInput: $input.all().length },\n  bestOverall: view(bestOverall),\n  bestWithin: {\n    km5:  view(best5km),\n    km10: view(best10km),\n  }\n};\n\nreturn [{ json: summary }];"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-64,448],"id":"31109543-9edc-4a4b-83e2-b007ed68a54e","name":"setupForSlack"},{"parameters":{"jsCode":"// Input: { lat: -34.85, lng: 138.6 } (replace with your webhook values)\nconst lat = $input.first().json.body.lat;\nconst lng = $input.first().json.body.lon;\n\n// Earth radius in km\nconst R = 6371;\n\n// 20 km in degrees\nconst dLat = (20 / R) * (180 / Math.PI);\nconst dLng = (20 / R) * (180 / Math.PI) / Math.cos(lat * Math.PI / 180);\n\n// Bounding box\nconst neLat = lat + dLat;\nconst neLng = lng + dLng;\nconst swLat = lat - dLat;\nconst swLng = lng - dLng;\n\nreturn [\n  {\n    json: {\n      neLat,\n      neLng,\n      swLat,\n      swLng,\n    }\n  }\n];"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-640,448],"id":"52addfdb-22b8-461b-9595-ead3bcfc9696","name":"setupLocationRange"},{"parameters":{"respondWith":"json","responseBody":"={{ { result: $json.result }.toJsonString() }}","options":{}},"type":"n8n-nodes-base.respondToWebhook","typeVersion":1.4,"position":[336,448],"id":"dcda77f4-7bab-44af-835b-18904c8577fe","name":"Respond to Webhook"},{"parameters":{"jsCode":"// Input: an array with one summary object\nconst summary = $input.first().json;\n\nfunction formatStation(label, s) {\n  if (!s) return `${label}: none.`;\n  return `${label}: ${s.price_cpl}, effective ${s.effective_price_cpl} at ${s.name} in ${s.suburb}, about ${Math.round(s.distance_km)} k's away.`;\n}\n\n// Build speech text\nlet result = '';\nresult += formatStation(\"Best overall\", summary.bestOverall) + ' ';\nresult += formatStation(\"Within 5 k's'\", summary.bestWithin?.km5) + ' ';\nresult += formatStation(\"Within 10 ks\", summary.bestWithin?.km10);\n\n// Return as a single object\nreturn [{\n  json: {\n    result\n  }\n}];"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[128,448],"id":"5fab0eb4-abe4-47aa-b038-e7783bd6f94b","name":"setupForSiri"},{"parameters":{"content":"## Version Control\n\n2025-09-11 18:40 LM - init\n2025-09-15 17:44 LM - changed the Slack output to a speech response\n2025-09-15 18:40 LM - updating for more flexible mode-logic","height":480,"width":940,"color":4},"type":"n8n-nodes-base.stickyNote","typeVersion":1,"position":[-848,608],"id":"98434366-65d9-4bf7-afad-d9c2df05d090","name":"Sticky Note3"}],"connections":{"HTTP Request":{"main":[[{"node":"pricesU91","type":"main","index":0}]]},"pricesU91":{"main":[[{"node":"setupForSlack","type":"main","index":0}]]},"Webhook":{"main":[[{"node":"setupLocationRange","type":"main","index":0}]]},"setupForSlack":{"main":[[{"node":"setupForSiri","type":"main","index":0}]]},"setupLocationRange":{"main":[[{"node":"HTTP Request","type":"main","index":0}]]},"setupForSiri":{"main":[[{"node":"Respond to Webhook","type":"main","index":0}]]}},"workflow_name":"Fuel Finder"}